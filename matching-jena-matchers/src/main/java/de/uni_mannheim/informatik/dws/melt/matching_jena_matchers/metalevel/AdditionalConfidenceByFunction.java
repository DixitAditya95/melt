package de.uni_mannheim.informatik.dws.melt.matching_jena_matchers.metalevel;

import de.uni_mannheim.informatik.dws.melt.matching_jena.MatcherYAAAJena;
import de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api.Alignment;
import de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api.Correspondence;
import java.util.AbstractMap;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.function.Function;
import org.apache.jena.ontology.OntModel;
import org.apache.jena.ontology.OntResource;
import org.apache.jena.rdf.model.Property;
import org.apache.jena.rdf.model.RDFNode;
import org.apache.jena.rdf.model.StmtIterator;
import org.apache.jena.vocabulary.RDFS;
import org.apache.jena.vocabulary.SKOS;

/**
 * Adds an additional confidence by a user chosen function which gets a ontResource and has to return a double.
 * The value will be computed for source and target.
 * If you want to add confidences for a correspondence then implement your own matcher and iterate over the alignment.
 */
public class AdditionalConfidenceByFunction extends MatcherYAAAJena{

    private Map<String, Function<OntResource,Double>> functions;
    
    /**
     * This adds a confidence by a given function.
     * The key for the confidence is AdditionalConfidenceByResourceFunction (so only use it once in a pipeline).
     * @param function the function to compute the confidence. Class {@code AdditionalConfidenceByFunction} has also some default functions.
     */
    public AdditionalConfidenceByFunction(Function<OntResource,Double> function){
        this(new AbstractMap.SimpleEntry<>("AdditionalConfidenceByFunction", function));
    }
    
    /**
     * This adds a confidence by a given function.
     * @param key the confidence key to use
     * @param function the function to compute the confidence
     */
    public AdditionalConfidenceByFunction(String key, Function<OntResource,Double> function){
        this(new AbstractMap.SimpleEntry<>(key, function));
    }
    
    /**
     * Multiple confidence functions. 
     * They can be generated by <code>AdditionalConfidenceByFunction(AbstractMap.SimpleEntry("foo", new Function....),AbstractMap.SimpleEntry("bar", AdditionalConfidenceByFunction.MAX_LABEL_LENGTH)) </code>
     * @param confidenceFunctions confidenceFunctions
     */
    public AdditionalConfidenceByFunction(Entry<String, Function<OntResource,Double>>... confidenceFunctions){
        this.functions = new HashMap();
        for(Entry<String, Function<OntResource,Double>> entry : confidenceFunctions){
            this.functions.put(entry.getKey(), entry.getValue());
        }
    }
    
    /**
     * Multiple confidence functions. 
     * @param confidenceFunctions map of functions with a corresponding confidence key.
     */
    public AdditionalConfidenceByFunction(Map<String, Function<OntResource,Double>> confidenceFunctions){
        this.functions = confidenceFunctions;
    }
    
    /**
     * Add an additional function with confidence key.
     * @param confidenceName the name for the confidence 
     * @param confidenceGenerator the function which generates the confidence
     */
    public void addFunction(String confidenceName, Function<OntResource,Double> confidenceGenerator){
        this.functions.put(confidenceName, confidenceGenerator);
    }
    
    
    @Override
    public Alignment match(OntModel source, OntModel target, Alignment inputAlignment, Properties properties) throws Exception {
        for(Correspondence c : inputAlignment){
            OntResource sourceResource = source.getOntResource(c.getEntityOne());
            OntResource targetResource = target.getOntResource(c.getEntityTwo());
            if(sourceResource == null || targetResource == null)
                continue;
            
            for(Entry<String, Function<OntResource,Double>> entry : this.functions.entrySet()){
                Double leftValue = entry.getValue().apply(sourceResource);
                if(leftValue == null)
                    continue;
                Double rightValue = entry.getValue().apply(targetResource);
                if(rightValue == null)
                    continue;
                c.addAdditionalConfidence(entry.getKey() + "_Left", leftValue);
                c.addAdditionalConfidence(entry.getKey() + "_Right", rightValue);
            }
        }
        return inputAlignment;
    }
        
    
    public static Function<OntResource,Double> MAX_LABEL_LENGTH = createMaxLiteralLengthFunction(RDFS.label);
    public static Function<OntResource,Double> MAX_ALT_LABEL_LENGTH = createMaxLiteralLengthFunction(SKOS.altLabel);
    
    public static Function<OntResource,Double> createMaxLiteralLengthFunction(Property p){
        return new Function<OntResource, Double>() {
            @Override
            public Double apply(OntResource r) {
                int length = 0;
                StmtIterator i = r.listProperties(p);
                while(i.hasNext()){
                    RDFNode n = i.next().getObject();
                    if(n.isLiteral()){
                        String text = n.asLiteral().getLexicalForm().trim();
                        if(text.length() > length){
                            length = text.length();
                        }
                    }
                }
                return (double)length;
            }
        };
    }
}
